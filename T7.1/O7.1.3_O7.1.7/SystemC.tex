
\chapter{System C}

\begin{description}
\item[\textcolor{green}{Author}] Author of the approaches description \textcolor{green}{Stefan Rieger (TWT)/ Frank Golatowski (Uni Rostock)}
\item[\textcolor{blue}{Assessor 1}] First assessor of the approaches \textcolor{blue}{Cecile Braunstein (Uni. Bremen)}
\item[\textcolor{magenta}{Assessor 2}] Second assessor of the approaches \textcolor{magenta}{Silvano Dal~Zilio / LAAS}
\end{description}

In the sequel, main text is under the responsibilities of the author.

\begin{author_comment}
Author can add comments using this format at any place.
\end{author_comment}

\begin{assessor1}
First assessor can add comments using this format at any place.
\end{assessor1}

\begin{assessor2}
Second assessor can add comments using this format at any place.
\end{assessor2}

When a note is required, please follow this list :
\begin{description}
\item[0] not recommended, not adapted, rejected
\item[1] weakly recommended, adapted after major improvements, weakly rejected
\item[2] recommended, adapted (with light improvements if necessary) weakly accepted
\item[3] highly recommended, well adapted,strongly accepted
\item[*] difficult to evaluate with a note (please add a comment under the table)
\end{description}

All the notes can be commented under each table.

\section{Presentation}

This section gives a quick presentation of the approach and the tool.

\begin{description}
\item[Name] SystemC
\item[Web site] \url{http://www.accellera.org/downloads/standards/systemc/about_systemc/}
\item[Licence] SystemC Open Source License
\end{description}

\paragraph{Abstract}

SystemC is a C++ library providing an event-driven simulation interface suitable for electronic system level design. It enables a system designer to simulate concurrent processes. SystemC processes can communicate in a simulated real-time environment, using channels of different datatypes (all C++ types and user defined types are supported). SystemC supports hardware and software synthesis (with the corresponding tools). SystemC models are executable.


\paragraph{Publications} Short list of publications on the approach (5 max)

\begin{itemize}
\item D. C. Black, SystemC: From the ground up. Springer, 2010.
\item IEEE 1666 Standard SystemC Language Reference Manual, \url{http://standards.ieee.org/getieee/1666/}
\item The ITEA MARTES Project, from UML to SystemC, \url{http://www.martes-itea.org/}
\item J. Bhasker, A SystemC Primer, Second Edition, Star Galaxy Publishing, 2004
\item F. Ghenassia (Editor), Transaction-Level Modeling with SystemC: TLM Concepts and Applications for Embedded Systems, Springer 2006
\end{itemize}

\section{Main usage of the approach}
\label{main_usage}

SystemC is suitable for system level design at various abstraction levels (from high level down to individual hardware components) and can thus be employed to build a full system model. Due to its modular design and abstraction principles sub-components and a lower abstraction level of the model can be considered as ``black boxes''. SystemC models can be executed and simulated allowing for testing of the entire model or individual components.

According to the figure \ref{fig:main_process}, for which phases do you recommend the approach (give a note from 0 to 3) :

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
System Analysis &1 & \textcolor{green}{0} & 1     & 2     \\
\hline
Sub-system formal design & 3     & 1    *  &  1 & \textcolor{blue}{5} \\
\hline
Software design &3 &3 & 3     & \textcolor{red}{\textbf{9}} \\
\hline
Software code generation &2 & 2    ** & 2     & \textcolor{blue}{6} \\
\hline
\end{tabular}
\begin{assessor1}
\begin{itemize}
\item[(*)] How is it formal ?
\begin{author_comment}
The question is whether you consider only \emph{fully} formal or also \emph{semi} formal modelling methods here. As there is no separate item for semi formal sub-system design I considered it to be included.
\end{author_comment}
\item[(**)] Is it the SysML to  SystemC code generation  you have in
  mind here ?
\begin{author_comment}
No, the generation of low-level software from the SystemC model.
\end{author_comment}
\end{itemize}
\end{assessor1}

According to the figure \ref{fig:main_process}, for which type of activities do you recommend the approach (give a note from 0 to 3) :

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Documentation & \textcolor{green}{0}   & \textcolor{green}{0} & \textcolor{green}{0} & \textcolor{green}{0} \\
\hline
Modeling &3 & 3     & 2     & \textcolor{magenta}{8} \\
\hline
Design &3 &3 & 3     & \textcolor{red}{\textbf{9}} \\
\hline
Code generation &3 & 2     *  & * & \textcolor{blue}{5} * \\
\hline
Verification &2 & 2    * & ** & 4    * \\
\hline
Validation &2 &3 & 2     & \textcolor{magenta}{7} \\
\hline
Safety analysis &2 & 1    * & ** & 3    * \\
\hline
\end{tabular}
\begin{assessor1}
This is not explained in the report or shown in  the provided example.

Simulation and testing techniques are quite straightforward as well as
assertion checking from the provided model.
\end{assessor1}

\begin{assessor2}
  \begin{item}
  \item[(*)] One of the problem here is that simulation of SystemC
    models do not take into account the execution platform, like for
    example the actual hardware limitation of the EVC or the
    characteristics of the API. How precisely should you model the
    hardware part of the system ?
\begin{author_comment}
If you would model the hardware in SystemC, you could have a quite exact model of the entire system. This, however, is not in the scope of openETCS and would increase the modelling effort tremendously. Which other approach takes into account the actual behaviour of the hardware? I don't see that this will be done in any of the approaches as we model only the software. The integration of the API should be doable.
\end{author_comment}
  \item[(**)] Simulation and testing can be used for V\&V, with the
    usual caveats associated with non-formal languages. I also agree
    with Assessor~1 on the fact that safety and verification
    capabilities are not really demonstrated right now. Actually I am
    quite doubtful about safety since the only type of safety analysis
    that I can see performed is error injection during the simulation.
\begin{author_comment}
You are right, there is no verification integrated into the current state of the model. This is due to time constraints. Of course, you will not be able to fully formally verify a SystemC model in general. You will have to use testing approaches.
\end{author_comment}
  \end{item}
\end{assessor2}

\paragraph{Known usages} Have you some examples of usage of this approach to compare with the OpenETCS objectives ?

SystemC has been applied, among others, in the following areas:

\begin{itemize}
\item Communication technology
\item Hardware design and simulation
\item Hardware and software synthesis
\item Sensor circuits
\item Automotive
\item Aerospace industry
\end{itemize}

SystemC is widely employed in industry. Among the members of the Accellera Systems Initiative responsible for SystemC are the following organisations:

AMD, ARM, Cadence, Intel, NXP, Qualcomm, Synopsys, Texas Instruments, Altera, Boeing, Cisco, Ericsson, Fraunhofer IIS, IBM, NEC, nVidia, Xilinx

Vendors supporting SystemC (according to \href{http://en.wikipedia.org/wiki/SystemC}{Wikipedia}):

Aldec, AutoESL, Cadence Design Systems, HCL Technologies, Calypto, CircuitSutra, CoFluent Design, CoSynth Synthesizer, CoWare, Forte Design Systems, Mentor Graphics, OVPsim, NEC CyberWorkBench, Imperas, Synopsys, SystemCrafter, JEDA Technologies, HIFSuite, Dynalith Systems, VWorks


\section{Language}
This section discusses the main element of the language.

Which are the main characteristics of the language :

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Informal language & \textcolor{green}{0}   & \textcolor{green}{0} & \textcolor{green}{0} & \textcolor{green}{0} \\
\hline
Semi-formal language &3 & 3    & 3     & \textcolor{red}{\textbf{9}} \\
\hline
Formal language &2 &1 & 1     & 4     \\
\hline
Structured language &3 &3 & 3     & \textcolor{red}{\textbf{9}} \\
\hline
Modular language &3 &3 & 3     & \textcolor{red}{\textbf{9}}  \\
\hline
Textual language &3 &3 & 3     & \textcolor{red}{\textbf{9}} \\
\hline
Mathematical symbols or code &2* &2* & 2     & \textcolor{blue}{6} \\
\hline
Graphical language &** & \textcolor{green}{0} **& \textcolor{green}{0} &  0* \\
\hline
\end{tabular}

\begin{author_comment}
* We would set this to 2, because there are languages where you can write the mathematical formula directly like in written text.
** Not graphical, but we are investigating SystemC and UML/SysML integration, the \href{http://www.martes-idea.org/}{ITEA MARTES Project} is addressing this aspect
\end{author_comment}
\begin{assessor1}
\begin{itemize}
\item[(*)] But it is possible to use a variety of C++ library
\begin{author_comment}
True.
\end{author_comment}
\item[(**)] SystemC itself is not a graphical language
\begin{author_comment}
True as well. We never stated anything else.
\end{author_comment}
\end{itemize}
\end{assessor1}

According to WP2 requirements, give a note for the capabilities of the language (from 0 to 3) :

\begin{tabular}{|l | c | c | c | c|}
  \hline
  & \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
  \hline
  Declarative formalization of properties (D2.6-02-066) &1 &1 & 1    & 3     \\
  \hline
  Simple formalization of properties (D2.6-02-066.01) &1 &1 &1 & 3     \\
  \hline
  Scalability : capability to design large model &3 &3 & 3     & \textcolor{red}{\textbf{9}} \\
  \hline
  Easily translatable to other languages (D2.6-02-068) & 2     & 2      & 2    * & \textcolor{blue}{6} \\
  \hline
  Executable directly (D2.6-02-071) &3 & 3      & * & \textcolor{blue}{6} * \\
  \hline
  Executable after translation to a code (D2.6-02-071) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
  (precise if the translation is automatic) & & & 2    *& 2    *\\
  \hline
  Simulation, animation (D2.6-02-071) &3* &3* &3 & \textcolor{red}{\textbf{9}} \\
  \hline
  Easily understandable (D2.6-02-065) &2 &2 &3 & \textcolor{magenta}{7} \\
  \hline
  Expertise level needed (0 High level, 3 few level) &1 &2 &1 & 4     \\
  \hline
  Standardization (D2.6-02-067) &3 &3 &3** & \textcolor{red}{\textbf{9}} \\
  \hline
  Documented (D2.6-02-067) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
  \hline
  Extensible language (D.2.6-01-28) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
  \hline
\end{tabular}

\begin{author_comment}
* Should be two rows. SystemC provides simulation but not animation.
\end{author_comment}
\begin{assessor1}
* Some library may be used to trace the value of  the variables from
simulation. his is not a code animation but this offer another view of
the model behaviors.
\end{assessor1}

\begin{assessor2}
\item[(*)] There is a large collection of tools providing translation
  from and to SystemC, so I am even willing to put a 3 for
  ``translatability''. Once again, to the best of my knowledge, there
  are no ``certified compiler'' for SystemC, like it is the case for
  SCADE for example, so it is necessary to check the result of the
  translation.
\item[(**)] It is not clear if (or where) all the proprietary tools
  follow the standards consistently. By definition, Accellera provides
  an implementation of the SystemC standard 
\end{assessor2}

\paragraph{Documentation} Describe how the language is documented, the existing guidelines, coding rules, standardization...

There is an IEEE Standard covering SystemC, an official specification from the Accellera Initiative and a plethora of third party literature and tutorials.

\paragraph{Language usage} Describe the possible restriction on the language

\begin{itemize}
\item As the language is based on C++ and thus inherits its expressivity there might be problems in static analysis if the models use the power of the language in an unrestricted manner.
\item The language is text-based and not graphical. However, there are approaches of integrating SystemC and UML/SysML. We are currently investigating in this issue.
\end{itemize}


\section{System Analysis}
This section discusses the usage of the approach for system analysis.
It can be skipped depending the results of \ref{main_usage}.

According WP2 requirements, how the approach can be involved for the sub-system requirement specification ?

\begin{author_comment}
This is not the main purpose of SystemC. Thus we skip this section.
\end{author_comment}

\section{Sub-System formal design}
This section discusses the usage of the approach for sub-system formal design.
It can be skipped depending the results of \ref{main_usage}.

Two kinds of model can be planned during this phase: semi-formal models to cover the SSRS (D2.6-02-047.01) and strictly formal models to focuss on some functional and safety aspects (D2.6-02-049). Obviously some strictly formal means can be used to define the semi-formal model.

\subsection{Semi-formal model}

Concerning semi-formal model, how the WP2 requirements are covered ?

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Consistency to SSRS (D2.6-02-047.02) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Coverage of SSRS (D2.6-02-047.02.01) &* &2 &* & 2    * \\
\hline
Coverage of SSHA (D2.6-02-047.02.02) &* &1 &* & 1    * \\
\hline
Management of requirement justification (D2.6-02-047.02.03) &2 &2 &2 & \textcolor{blue}{6} \\
\hline
Traceability to SSRS (D2.6-02-047.02.05) &** &2** &* & 2    * \\
\hline
Traceability of exported requirements (D2.6-02-047.02.06) &*** & 2    **&* & 2    * \\
\hline
Simulation or animation (D2.6-02-048 partial) &3**** & 3     &3 & \textcolor{red}{\textbf{9}} \\
\hline
Execution (D2.6-02-048 partial) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Extensible to strictly formal model (D2.6-02-049.3) &2 &1 &1 & 4     \\
\hline
Easy to refine towards strictly formal model (D2.6-02-049.4) &2 &2 &2 & \textcolor{blue}{6} \\
\hline
Extensible and modular design (D2.6-02-050) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Extensible to software architecture and design (D2.6-02-068) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
\end{tabular}

\begin{author_comment}
* The coverage has to be achieved by the \textbf{model}, not by the language or tool and should be removed from the table.\\
** See table above\\
*** What are ``exported requirements''?\\
**** This cannot be extracted from the requirement as the requirement is on execution which is in the next row.
\end{author_comment}
\begin{assessor1}
\begin{itemize}
\item[*] The coverage may just be a metric, the number of function
  implemented versus the total ETCS functions. I think this can be
  easily added
\item[**] This may be achieve by standardized comments.
\end{itemize}
\end{assessor1}

\begin{assessor2}
  \begin{itemize}
  \item[*] I am not familiar enough with the SSRS and SSHA to provide a
    valid answer at the moment.
  \end{itemize}  
\end{assessor2}


Concerning safety properties management, how the WP2 requirements are covered ?

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Safety function isolation (D2.6-02-052) &* & * & * & * \\
\hline
Safety properties formalisation (D2.6-02-057) &2 &1* & * & 3    * \\
\hline
Logical expression (D2.6-02-066.02.01) &3 &3 &3 & \textcolor{red}{\textbf{9}}  \\
\hline
Timing constraints (D2.6-02-066.02.02) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Safety properties validation (D2.6-02-058.02) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Logical properties assertion (D2.6-02-072) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Check of assertions (D2.6-02-072.1) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
\end{tabular}


\begin{author_comment}
* Item not clear to me, should be a requirement for the actual implementation, not a model
\end{author_comment}

\begin{assessor1}
(*) The safety analysis may be done with external temporal model
checker for example or by means of monitor. 
\begin{author_comment}
There are approaches for model checking SystemC models, such as transformations to the timed model checker UPPAAL. However, as far as I know there are no ready-to-use (free) tools.
\end{author_comment}
\end{assessor1}
Does the language allow to formalize (D2.6-02-069):

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
State machines &3 &3 & 2    * & \textcolor{magenta}{8} \\
\hline
Time-outs &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Truth tables &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Arithmetic &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Braking curves &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Logical statements &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Message and fields &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
\end{tabular}

\begin{assessor2}
  \begin{itemize}
  \item[*] State machines are not part of the language and should be
    ``interpreted'' in the code.
\begin{author_comment}
I am not exactly sure what is meant with ``interpreted'' here. In our model we provided an example how you can transform state machines, e.g., SysML statecharts, to SystemC (or any other procedural programming language) in a structured manner.
\end{author_comment}
  \end{itemize}  
\end{assessor2}



\paragraph{Additional comments on semi-formal model} Do you think your semi-formal model is sufficient to cover a safe design of the on-board unit until code generation ?
All comments on links to other models, validation and verification activities are welcomed.

\subsection{Strictly formal model}

\begin{author_comment}
Not filled, since we do not consider SystemC to be a strictly formal modelling language, as it has no mathematically formalized sematics. Fully formal models should also support ``really'' formal verification (not only testing) which requires additional work here. However, there are many approaches in the literature to, e.g., apply model checking to SystemC models.
\end{author_comment}


\paragraph{Additional comments on strictly formal model} Do you think your strictly formal model can be directly defined from the SSRS ?
All comments on links to other models, validation and verification activities are welcomed.


\section{Software design}
This section discusses the usage of the approach for software design.
It can be skipped depending the results of \ref{main_usage}.

\begin{author_comment}
SystemC allows system, software and hardware design and is thus suitable.
\end{author_comment}

\subsection{Functional design}

How the approach allows to produce a functional software model of the on-board unit ?

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Derivation from system semi-formal model &* &2 &2 & 4    * \\
\hline
Software architecture description &3 &3 &3* & \textcolor{red}{\textbf{9}} \\
\hline
Software constraints &3 &3 &3* & \textcolor{red}{\textbf{9}} \\
\hline
Traceability &2** &2 &2* & \textcolor{blue}{6} \\
\hline
Executable &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
\end{tabular}

\begin{author_comment}
* Derivation not necessary because the model is fully executable\\
** Can possibly be covered by an associated SysML model. In addition, standardised, machine readable comments in the code could be used.\\
\end{author_comment}

\begin{assessor2}
  \begin{itemize}
  \item[*] The architecture description cannot be easily extracted
    from the source files, it is spread around the source code; this
    is not a problem if SystemC is only use as the target of
    transformations though.
\begin{author_comment}
True. That's why we advocate a SysML-based approach generating (parts) of the SystemC model from a more abstract SysML model.
\end{author_comment}
  \end{itemize}  
\end{assessor2}


\subsection{SSIL4 design}

How the approach allows to produce in safety a software model ?

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Derivation from system semi-formal or strictly formal model &* & * &2* & 2    * \\
\hline
Software architecture description &3 & 3     &3 & \textcolor{red}{\textbf{9}} \\
\hline
Software constraints &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Traceability &2** &2 &2 & \textcolor{blue}{6} \\
\hline
Executable &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Conformance to EN50128 § 7.2 &*** & \textcolor{green}{0}   & *  & \textcolor{green}{0} * \\
\hline
Conformance to EN50128 § 7.3 &*** &3 &  * & 3    * \\
\hline
Conformance to EN50128 § 7.4 &*** &3 & * & 3    * \\
\hline
\end{tabular}
\begin{assessor1}
\begin{itemize}
\item  EN50128 § 7.2 : Describe complete set of requirements for the
  software + describe the overall software test specification
\item EN50128 § 7.3 :  Develop a software architecture 
\item EN50128 § 7.4 : Develop a software component design
\end{itemize}
\end{assessor1}

\begin{author_comment}
* Item unclear to me\\
** Can possibly be covered by an associated SysML model. In addition, standardised, machine readable comments in the code could be used.\\
*** No idea, why don't you cite these items?
\end{author_comment}

\begin{assessor2}
  \begin{itemize}
  \item[*] The approach followed in the demonstrator is based on
    Model-Driven Engineering (with the MOF model to text transform)
    and the use of the Acceleo Eclipse plugin.
  \end{itemize}  
\end{assessor2}



Which criteria for software architecture are covered by the methodology
(see EN50128 table A.3) :

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Defensive programming &* &* & * & * \\
\hline
Fault detection \& diagnostic &2 &2 &2 & \textcolor{blue}{6} \\
\hline
Error detecting code &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Failure assertion programming &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Diverse programming &* &* & * & * \\
\hline
Memorising executed cases &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Software error effect analysis &* &2* & * & 2    * \\
\hline
Fully defined interface &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Modelling &3 & * &2 & \textcolor{blue}{5} * \\
\hline
Structured methodology &3 & * & * & 3    * \\
\hline
\end{tabular}

\begin{author_comment}
 * SystemC is a language and no methodology. These methodologies can be applied for most languages.
\end{author_comment}
\begin{assessor1}
* One can create mutant.
\end{assessor1}

\section{Software code generation}
This section discusses the usage of the approach for software code generation.
It can be skipped depending the results of \ref{main_usage}.

Which criteria for software design and implementation are covered by the methodology
(see EN50128 table A.4) :

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Formal methods & \textcolor{green}{0}  * & \textcolor{green}{0}   & \textcolor{green}{0}   & \textcolor{green}{0} \\
\hline
Modeling &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Modular approach (mandatory) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Components &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Design and coding standards (mandatory) &** &3 &3 & \textcolor{blue}{6} * \\
\hline
Strongly typed programming language &2 &2 &2 & \textcolor{blue}{6} \\
\hline

\end{tabular}

\begin{author_comment}
 * Not integrated in the language, requires external tools/methods (there's a plethora of approaches in the literature)\\
 ** Have to be stated by the project
\end{author_comment}

\section{Main usage of the tool}
\label{main_usage}

This section discusses the main usage of the tool.

Which task are covered by the tool ?


\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Modelling support &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Automatic translation &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Code Generation &2* & * & \textcolor{green}{0}   & 2    * \\
\hline
Model verification &2 & * &2 & 4    * \\
\hline
Test generation &2 & \textcolor{green}{0}   & \textcolor{green}{0}   & 2     \\
\hline
Simulation, execution, debugging &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Formal proof & \textcolor{green}{0}   &3 &2* &  5\\
\hline
\end{tabular}

\begin{author_comment}
 * The model is itself executable
\end{author_comment}



\begin{assessor2}
  \begin{itemize}
  \item[*] There are some model-checking tools that can accept SystemC
    code; for example CBMC in the case of a restricted set of
    properties (see
    e.g.~\url{http://www.informatik.uni-bremen.de/agra/doc/konf/10MEMOCODE-tlmpc.pdf}). Nonetheless
    I am not sure that we have the expertise for using these
    prototypes in the project.
\begin{author_comment}
I believe that would have to resort to (model-based) testing here, if we want to verify the whole model. But this will be the case anyway for most approaches as we will not be able to formally verify the entire ETCS system. This is simply infeasible. However, we could try to apply model checking to parts of it. The SystemC-frontend of CBMC is currently not supporting full SystemC (there are some restrictions) but the authors are working on it. This is a work done in the context of the Artemis Project \emph{VeTeSS} (\url{http://vetess.eu/}).
\end{author_comment}
  \end{itemize}  
\end{assessor2}




\paragraph{Modelling support}
Does the tool provide a textual or a graphical editor ?

It is a textual language. We are investigating in a SysML/UML integration, see above.

\paragraph{Automatic translation and code generation}
Which translation or code generation is supported by the tool ?

The model is itself executable with an integrated simulation environment, but there is a variety of tool providers for software synthesis (see above)

\paragraph{Model verification}
Which verification on models are provided by the tool?

Simulation, Testing

\paragraph{Test generation}
Does the tool allow to generate tests ? For which purpose ?

There are extensions that support generating random tests with constraints.

\paragraph{Simulation, execution, debugging}
Does the tool allow to simulate or to debbug step by step a model or a code ?

Simulation is supported, debugging can be done by any C++ debugger.

\paragraph{Formal proof}
Does the tool allow formal proof ? How ?

No, only by means of external tools


\section{Use of the tool}


According WP2 requirements, give a note for characteristics of the use of the tool (from 0 to 3) :

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Open Source (D2.6-02-074) &3 &3 &3* & \textcolor{red}{\textbf{9}} \\
\hline
Portability to operating systems (D2.6-02-075) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Cooperation of tools (D2.6-02-076) &* &2$\clubsuit$ &2 & 4    * \\
\hline
Robustness (D2.6-02-078) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Modularity (D2.6-02-078.1) &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Documentation management (D2.6-02-078.02) &** &2 &2 & 4    * \\
\hline
Distributed software development (D2.6-02-078.03) &3*** &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Simultaneous multi-users (D2.6-02-078.04) &3*** & 3    &3 & \textcolor{red}{\textbf{9}} \\
\hline
Issue tracking (D2.6-02-078.05) &** &1 &2 & 3    * \\
\hline
Differences between models (D2.6-02-078.06) &3*** &3 &2 & \textcolor{magenta}{8} \\
\hline
Version management (D2.6-02-078.07) &3*** &2 &2 & \textcolor{magenta}{7} \\
\hline
Concurrent version development (D2.6-02-078.08) &3*** &2 &2 & \textcolor{magenta}{7} \\
\hline
Model-based version control (D2.6-02-078.09) &**** & \textcolor{green}{0}   & \textcolor{green}{0}   & \textcolor{green}{0} * \\
\hline
Role traceability (D2.6-02-078.10) &* & \textcolor{green}{0}   & \textcolor{green}{0}   & \textcolor{green}{0} * \\
\hline
Safety version traceability (D2.6-02-078.11) &* & \textcolor{green}{0}   & \textcolor{green}{0}   & \textcolor{green}{0} * \\
\hline
Model traceability (D2.6-02-079) &***** & * & \textcolor{green}{0}   & \textcolor{green}{0} * \\
\hline
Tool chain integration &2****** &3 &3 & \textcolor{magenta}{8} \\
\hline
Scalability &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
\end{tabular}

\begin{author_comment}
  * Unclear to me\\
  ** Not directly; by means of external tools such as Doxygen (or in the case of issue tracking, e.g., GitHub)\\
 *** By means of versioning systems such as Git or SVN\\
**** For SystemC text-based version control is equivalent to model-based version control.\\
***** Can possibly be covered by an associated SysML model. In addition, standardised, machine readable comments in the code could be used.\\
****** Tool chain integration can be achieved at different levels. E.g., SystemC can be the target language from graphical, higher-level languages (e.g., SysML). SystemC models are executable and thus code generation is possibly no issue if we want to obtain just an executable model but no real code running on the target platform (which is out of scope for openETCS).
\end{author_comment}
\begin{assessor1}
\begin{itemize}
\item[$\clubsuit$] SystemC may be used in a tool chain cf. hardware synthesis
\end{itemize}
\end{assessor1}



\begin{assessor2}
  \begin{itemize}
  \item[*] Access to SystemC is restricted and subject to the terms of
    the SystemC Open Source License
    (\url{http://www.accellera.org/about/policies/SystemC_Open_Source_License_v3.3.pdf}). YAOSLA
    = Yet Another Open Source Licence Agreement !
  \end{itemize}  
\end{assessor2}


\section{Certifiability}

This section discusses how the tool can be classified according EN50128 requirements (D2.6-02-085).

\begin{author_comment}
  We do not have the information to fill this completely. But the broad industrial usage suggests that certifiability should not be an issue.
\end{author_comment}

\begin{tabular}{|l | c | c | c | c|}
\hline
& \textcolor{green}{Author} & \textcolor{blue}{Assessor 1} & \textcolor{magenta}{Assessor 2} & Total \\
\hline
Tool manual (D.2.6-01-42.02) & * &3 &3 & \textcolor{blue}{6} * \\
\hline
Proof of correctness (D.2.6-01-42.03) &*  & \textcolor{green}{0}   & \textcolor{green}{0}   & \textcolor{green}{0} *\\
\hline
Existing industrial usage &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Model verification & * & \textcolor{green}{0}   & \textcolor{green}{0}   & \textcolor{green}{0} *\\
\hline
Test generation & * & \textcolor{green}{0}   & \textcolor{green}{0}   & \textcolor{green}{0} *\\
\hline
Simulation, execution, debugging &3 &3 &3 & \textcolor{red}{\textbf{9}} \\
\hline
Formal proof &*  & \textcolor{green}{0}   & \textcolor{green}{0}   & \textcolor{green}{0} * \\
\hline
\end{tabular}

\paragraph{Other elements for tool certification}

\section{Other comments}
Please to give free comments on the approach.

\subsection{Assessor 1 summary}
SystemC is a powerful tool for modeling concurrent systems. The key
feature is that the model is executable with  an integrate simulation
environment. Moreover, the user just need a C++ compiler and an editor
to edit and run the model. 
The simulation is event-driven  with notion of time, so the model
may be used for time-simulation.
One big advantage of this approach is to be able to use different c++
library like arithmetic library. It is also possible to do
architectural exploration. This is not in the scope of the project but
this can be useful to speed up some computation by hardware
co-processor. SystemC may simulate hardware and software components together.
Furthermore, it is possible to replace the simulation kernel by an
appropriate run-time system  to then be able
to take into account the OBU hardware and to be conform with some OS
API.

The integration with the test from SUBSET076 seems quite straightforward
and can be easily realized. 

The approach proposed with SysML seems promising and shows that
SystemC is easily integrated in a tool chain and be good candidate for
target code. Nevertheless the translation or the result of the
translation should be proven. Moreover, for the moment the description
is more at high level and the software should be refined to be
embedded. The definition of the refinement is not yet well-defined.

\subsection{Assessor 2 summary}
\label{sec:assessor-2-summary}

While SystemC has strong similarities with VHDL and is often only
presented as an hardware description language, it is also widely used
in the automotive and avionic industries to provide a high-level,
executable models for the dynamic architecture of systems. In this
respect, its use in the industry is close in spirit to technologies
like Matlab/Simulink or even SCADE.

Actually the comparison with Matlab/Simulink is quite interesting
since both technologies face similar problems, like for instance a
lack of a proper, unambiguous semantics (partly because of the ease
with which the language can be extended). They also share similar
advantages: very efficient tooling; a large community of users; a very
versatile and expressive language; etc.

SystemC can be used for hardware synthesis (e.g. FPGA) or for
generating executable code (software); one of its distinctive
advantage with respect to the other modeling languages presented in
this document is the large collection of simulators that are
available. This makes it a good candidate for testing at the subsystem
level and for early architecture exploration; e.g. for architecture
dimensioning. Nonetheless it is not clear that different simulators
will produce equivalent, reproducible results. This is my motivation
for attributing a ``1'' for its applicability during the ``Sub-system
formal design'' phase (because of the \emph{formal}).

In the proposal from TWT and Uni. Rostock, SystemC is used as the
target language in a transformation from SysML. When restricted to
this particular usage, some of the problems with the approach could be
lessened. The problem of proving that this transformation preserves
the semantics of SysML still remains. Still, SystemC could be an
interesting choice, in parallel with other modeling languages, as a
way to provide ``technology/design diversity'' and therefore have a
more dependable system.




\chapter{Verification and Validation}
\label{sec:VnV}

This section is dedicated to tools and means for verification and validation.

\section{Candidates}


The list of initial candidates is shown below.  Those tools without a a reference on a subsection have not been evaluated further, due to lack of engagement (no partner was willing to sponsor such an evaluation).

\begin{description}

\item [System C] see \ref{sec:systemC}.
\item [UPPAAL] see \ref{sec: UPPAALL}.
\item [CPN tools] see \ref{sec:CPN-Tools}
\item [RT-Tester] see \ref{sec:RT-Tester}
\item [Tools around Classical B (ProB, SMT solver,...)] see \ref{sec:ClassicalB}
\item [Rodin and Pluggins] see \ref{sec:eventb_safe}
\item [Frama-C] see \ref{sec:frama-c}
\item [Matelo]
\item [Scade Suite]
\item [Fiacre and Tina]
\item [Diversity]
\item [SPIN]
\end{description}

\subsection{SystemC}
\label{sec:systemC}

\begin{description}
\item[Name] SystemC
\item[Web site] \url{www.accellera.org/downloads/standards/systemc/about_systemc/}
\item[Licence] SystemC Open Source License
\end{description}

\paragraph{Abstract} SystemC is a C++ library providing an event-driven simulation interface suitable for electronic system level design. It enables a system designer to simulate concurrent processes. SystemC processes can communicate in a simulated real-time environment, using channels of different datatypes (all C++ types and user defined types are supported). SystemC supports hardware and software synthesis (with the corresponding tools). SystemC models are executable.

\paragraph{Publications} 

\begin{itemize}
\item D. C. Black, SystemC: From the ground up. Springer, 2010.
\item IEEE 1666 Standard SystemC Language Reference Manual, \url{http://standards.ieee.org/getieee/1666/}
\item The ITEA MARTES Project, from UML to SystemC, \url{http://www.martes-itea.org/}
\item J. Bhasker, A SystemC Primer, Second Edition, Star Galaxy Publishing, 2004
\item F. Ghenassia (Editor), Transaction-Level Modeling with SystemC: TLM Concepts and
Applications for Embedded Systems, Springer 2006
\end{itemize}


A quantitative evaluation is available in \url{https://github.com/openETCS/toolchain/blob/master/T7.2/O7.2.1_VnV/O7-2-1_VnV.pdf}

\paragraph{Added value for OpenETCS project}

SystemC can be used for a quantitative evaluation of the specification and a system model. Although it could be used for a model of the ETCS system, it has been decided to use SCADE instead. However, the usage of SystemC models as test models will provide a significant benefit to the project. Especially for aspects where timing is important, such as braking curves computation, SystemC can be used for a quantitiative analysis. In addition, performance on different hardware platforms can be evaluated.

\paragraph{Integration in OpenETCS process and toolchain}

SystemC can be integrated with SysML:

\begin{itemize}
\item Transformation from SysML, e.g., by using Acceleo
\item SystemC provides executable models
\item Allows performance evaluation with target hardware
\end{itemize}

\subsection{UPPAAL}
\label{sec: UPPAALL}

\begin{description}
\item[Name] UPPAAL
\item[Web site] www.uppaal.org
\item[Licence] Academic free or commercial license
\end{description}

\paragraph{Abstract} Uppaal is an integrated tool environment for modeling, validation and verification of real-time systems modeled as networks of timed automata, extended with data types (bounded integers, arrays, etc.).

\paragraph{Publications} Short list of publications on the approach (5 max)
Please refer to \verb|http://dblp.org/search/#query=uppaal|



A quantitative evaluation is available in \url{https://github.com/openETCS/toolchain/blob/master/T7.2/O7.2.1_VnV/O7-2-1_VnV.pdf}


\paragraph{Added value for OpenETCS project}

\begin{itemize}
  \item Dedicated tool for modeling with timed automata
  \item Verification of real-time properties (model checking)
  \item Graphical simulation and modelling tool
\end{itemize}


\paragraph{Integration in OpenETCS process and toolchain}

Integration would be possible based on model transformation from, e.g., SysML statecharts with timing annotations. This could be achieved with tools such as Acceleo or Xtend.

\subsection{CPN Tools}
\label{sec:CPN-Tools}

\begin{description}
\item[Name] CPN Tools
\item[Website] http://cpntools.org/
\item[Licence] Open Source (GPL/LGPL)
\end{description}

\paragraph{Abstract} CPN Tools is a tool for editing, simulating, and analyzing Colored Petri nets.

The tool features incremental syntax checking and code generation, which take place while a net is being constructed. A fast simulator efficiently handles untimed and timed nets. Full and partial state spaces can be generated and analyzed, and a standard state space report contains information, such as boundedness properties and liveness properties.

\paragraph{Publications} Please refer to http://cpntools.org/publications

Slides available on github \url{https://github.com/openETCS/model-evaluation/blob/master/Telco_Secondary_slides/b-Introduction_CPNTools.pdf}.

A quantitative evaluation is available in \url{https://github.com/openETCS/toolchain/blob/master/T7.2/O7.2.1_VnV/O7-2-1_VnV.pdf}

\paragraph{Added value for OpenETCS project}

Petri Nets as a means of description are used in research an in industrial applications used for Process Modeling, Data analysis, Software design and Reliability engineering. Coloured Petri Nets are  High-level Petri Nets which are mainly used to describe, simulate and validated communication between humans and/or computers. As a means of description Coloured and  Hierarchic Petri nets allow to use one uniform means of description for the entire development cycle, starting with  the specification through to  implementation. 
Coloured petri nets are standardised as part of the high level petri nets in ISO/IEC 15909 Systems and software engineering - High-level Petri nets. The use of petri nets for the system dependability analysis is standardised in IEC 62551 Analysis techniques for dependability - Petri net modeling. In addition Coloured petri nets and the CPN Tools are introduced and documented in the book \textit{Coloured Petri Nets -- Modeling and Validation of Concurrent Systems} by K. Jensen and L.M. Kristensen. CPN Tools is a mature tool suite for coloured petri nets which provides support to edit, check, simulate and analyse nets on all relevant abstraction levels. CPN Tools has a graphical editor to model nets and provides various methods to analyse the nets, most importantly a reachability analysis. 

Petri nets are a strictly formal means of description suited for formal proof of behavioural and structural properties. The nets are mainly verified by generation and analysis of the state space. The tool supports the calculation and drawing of the state space, which is used to verify certain logical and temporal properties of the system. Additional model checker can be combined with the tool to provide additional functionalities. In context of the openETCS work coloured petri nets and CPN Tools provide a variable and efficient option for test models to validate the behaviour of the openETCS model. Especially, CPN Tools models can be used to specify and test timing properties.

The simulation engine of CPN tools provides a powerful simulation of petri nets and has a number of debugging functions. It does not support test generation, but provides interfaces for other tools to do so. Correspondingly, tools like SPENAT can be used to generate and manage all kinds of tests for the nets created with CPN Tools. 

\paragraph{Integration in OpenETCS process and toolchain}

CPN Tools is a mainly open source and for free tool suite which provides a number of interfaces to interact with other modeling tools and simulations. Depending on the specific use of CPN Tools to validate model behaviour or specifications these interfaces can be used co-simulated with SysML or SCADE models to run test cases. CPN Tools can also be as an independent to to just build test models and derive a number of test cases. 

%------------------------------- RT-Tester
\subsection{RT-Tester}
\label{sec:RT-Tester}

\begin{description}
\item[Name] RT-Tester
\item[Web site] http://www.verified.de/en/products/rt-tester
\item[Licence] Mixed:
  \begin{itemize}
    \item Generator:  closed
    \item SMT Solver: open
    \item GUI (eclipse plug-in): open
  \end{itemize}
\end{description}

\paragraph{Abstract}
The RT-Tester test automation tool, made by Verified, performs
automatic test generation, test execution and real-time test
evaluation.  It supports different testing approach such as unit
testing, software integration testing for component, hardware/software
integration testing and system integration testing.  
The tool generates automatically behavioral tests that covers the
classical criteria such as  reachable state, branch and MC/DC.
The RT-Tester also implements the so-called  model-based testing approach: 
starting from a test model design with UML/SysML, the RT-tester fully
automatically generates test cases. Moreover the test model may be
directly linked to the requirements, thus the requirement coverage may
also be ensured.

The RT-tester provides the following features :
\begin{itemize}
\item Automated Test Case Generation 
\item Automated Test Data and Test Oracles Generation 
\item Automated Test Procedure Generation 
\item Automated Requirement Tracing 
\item Test Management system 
\item Test Report Generation
\end{itemize}


Note that the RT-tester model based testing has be qualified according
to ISO 26262.

\paragraph{Publications}

\begin{itemize}
\item Jan Peleska, Elena Vorobev, and Florian Lapschies. Automated test case generation with smt-solving
and abstract interpretation. In Mihaela Bobaru, Klaus Havelund, GerardJ. Holzmann, and Rajeev
Joshi, editors, NASA Formal Methods, volume 6617 of Lecture Notes in Computer Science, pages
298â€“312. Springer Berlin Heidelberg, 2011.
\item Jan Peleska, Elena Vorobev, Florian Lapschies, and Cornelia Zahlten. Automated model-based
testing with RT-Tester. Technical report, UniversitÃ¤t Bremen, 2011.
\item JÃ¶rg Brauer, Jan Peleska, and Uwe Schulze. Efficient and trustworthy tool qualification for model-
based testing tools. In Brian Nielsen and Carsten Weise, editors, Testing Software and Systems,
volume 7641 of Lecture Notes in Computer Science, pages 8â€“23. Springer Berlin Heidelberg, 2012.
\item Verified Systems International GmbH. Verified :: Products. http://www.verified.de/en/products.


\end{itemize} 

\paragraph{Added value for OpenETCS project}

RT-Tester will add  an automated test case and test data generator
that interprets test models directly describes in SysML. 
The test models may specify concurrent sub-components of
SUT (System Under Test) and TE (Test Environment), and timing
conditions using dense time (i. e., continuous physical time) and 
an arbitrary number of timers. 

Another added value is that the tool also provides a simulation
environment that can directly generate C code from the SysML model and
run the tests.
The code generator may also be adapted to other purposes.

\paragraph{Integration in OpenETCS process and toolchain}

\begin{itemize}
  \item GUI via an eclipse plug-in already exist,
  \item read SysML model
  \item Can run SCADE generated code
\end{itemize}

\subsection{ClassicalB Tools}
\label{sec:ClassicalB}

\begin{description}
\item[Name] AtelierB, ProB, SMT solver
\item[Web site] Various, see Publciations below.
\item[Licence] Mixed:
  \begin{itemize}
    \item Proof Generator:  closed
    \item AtelierB checkers and translators open
    \item ProB, SMT solvers: open
  \end{itemize}
\end{description}

\paragraph{Abstract}

A B model is a textual and formal specification covering the functional be-
haviour of a safety critical software. It is usually written based on a high-level
specification (informal or formal specification, for example SysML or a natural
language). It is gradually refined, starting at the top with an abstract notation
and ending at the bottom with sequential instructions â€” which are then auo-
matically translated in a target language such as C or Ada.
Thus, we define three objects of verification and validation: the specification,
the B model and the generated source code.
Validation consists of:
\begin{itemize}

\item guaranteeing the functional adequacy between the specification and the
model (this can be achieved, for example, through review and proofread-
ing),
\item building a test environment around the generated source code and test it.

\end{itemize}

\paragraph{Publications}

\begin{itemize}
\item AtelierB \url{http://www.atelierb.eu/en}
\item ProB \url{http://www.formalmind.com}

\end{itemize} 

Slides are available on github \url{https://github.com/openETCS/model-evaluation/blob/master/Telco_Secondary_slides/ClassicalB_VnV.pdf}.

Detailled use of the tool and results on an example are available on github \url{https://github.com/openETCS/validation/blob/master/VnVUserStories/VnVUserStorySysterel/04-Results/b-ClassicalB-VnV/BmodelVnV.pdf}.

\paragraph{Added value for OpenETCS project}

A set of tools are available to proceed on formal design and verification and validation of critical systems.
Some of these tools are :
\begin{itemize}
\item open-source
\item mature, with large use in railway domain
\item qualified for SIL4 design 
\item allow to cover all the process from software design to executable code generation
\end{itemize}



\paragraph{Integration in OpenETCS process and toolchain}

Such kind of approach is a mature open-source alternative to the Scade toolchain.

%---------------------------------------------------------------------
\subsection{Frama-C}\label{sec:frama-c}
\begin{description}
\item[Name] Frama-C
\item[Web site] \url{http://frama-c.com/}
\item[Licence] LGPL 2.1
  \begin{itemize}
    \item Some plug-ins outside of the main distribution are closed-source.
  \end{itemize}
\end{description}

\paragraph{Abstract}
Frama-C is a framework dedicated to the analysis of C programs. It comes
with a formal specification language, ACSL, that allows to describe the
contracts that each function is supposed to fulfill It features a
number of plug-ins that perform various verification tasks. In particular,
Value analysis is an abstract interpretation-based plugin that can verify the
absence of run-time error for any execution of the program, and WP is an 
Hoare-logic based plug-in that can modularly check that an implementation
is conforming to its ACSL specification with the help of automated theorem
provers. Frama-C is also meant to be extensible, and it is easy to tailor
the generic plugins toward specific VnV tasks.

\paragraph{Publications}

\begin{itemize}
\item Pascal Cuoq, Florent Kirchner, Nikolai Kosmatov, Virgile Prevosto,
  Julien Signoles and Boris Yakobowski. Frama-C: a Software Analysis
  Perspective. Proceedings of SEFM 2012.
\item LoÃ¯c Correnson and Julien Signoles. Combining Analysises for
  C Program Verification. Proceedings of FMICS 2012
\item Jochen Burghardt, Jens Gerlach, Kerstin Hartig, Hans Pohl and Juan Soto.
  ACSL by Example, a fairly complete tour of ACSL features through
  various functions inspired from C++ STL.
\item Patrick Baudin, LoÃ¯c Correnson and Zaynah Dargaye, WP plugin manual.
\url{http://frama-c.com/download/wp-manual-Fluorine-20130601.pdf}
\item Pascal Cuoq, Boris Yakobowski and Virgile Prevosto.
  Frama-C's value analysis plugin manual. 
  \url{http://frama-c.com/download/frama-c-value-analysis.pdf}
\end{itemize}

Slides of Frama-C presentation are available on github
\url{https://github.com/openETCS/model-evaluation/blob/master/Telco_Secondary_slides/c-frama-c-secondary-tools-presentation.pdf}.

Specification and verification activities over the \texttt{bitwalker} code from
Siemens have been conducted by Fraunhofer FOKUS with support from CEA LIST.
The development is available on github: \url{https://github.com/openETCS/validation/tree/master/VnVUserStories/VnVUserStoryFraunhoferFOKUS}

\paragraph{Added value for OpenETCS project}

Frama-C can be used mainly for C code verification (either for manually written
code or code generated from a non-qualified tool). Abstract interpretation
and deductive verification plug-ins allow checking for absence of run-time
error (arithmetic overflows, division by zero, invalid pointer
dereference,...), as well as verifying functional properties expressed as
ACSL contracts.

Although Frama-C has not been formally qualified, there has been some reflection
on how a qualification process in the context of DO-178 verification activities
would be conducted.

A quantitative evaluation is available in \url{https://github.com/openETCS/toolchain/blob/master/T7.2/O7.2.1_VnV/O7-2-1_VnV.pdf}

\paragraph{Integration in OpenETCS process and toolchain}

An Eclipse plug-in is available 
(FCDT: \url{http://gforge.enseeiht.fr/projects/fcdt/}) for launching some
analyses from the Eclipse framework.

An interesting subject for the integration of Frama-C in the OpenETCS process
concerns the translation from SysML, Scade and/or B models into ACSL
specifications against which code could be verified. Such translation from
high-level models would also encompass traceability information, in order to
relate Frama-C proofs (or alarms) to the appropriate high-level property.

\section{Selected means and tools}

As of this writing, no final tools have been selected.  The V\&V team will take advantage of the evaluation, as the need for tools arises.